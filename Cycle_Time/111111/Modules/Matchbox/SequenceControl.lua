-------------------------------------------------------------------
----***************************************************************
----actions sequence control
----***************************************************************
-------------------------------------------------------------------

local SequenceControl = {}
local comFunc = require("Matchbox/CommonFunc")
local Log = require("Matchbox/logging")
local techFunctionTable = nil
local Record = require 'Matchbox/record'
local conditionModule = require 'Matchbox/Condition'

-- a table return key as value; used to handle string input.
local stringConst = {}
setmetatable(stringConst, {__index = function(t, k) return k end})


-- create dummy nodes to merge globals and conditions tables
-- generated by multiple parallel test groups
-- and return resolvable of merged tables
local function finishParallelGroup(dag, testName, lastNodeInThreads, forkRoot)
    local allGlobals = {}
    local allConditions = {}
    local r = nil
    local index = 1
    for _, r in pairs(lastNodeInThreads) do
        -- tech lua returns (globals, conditions)
        allGlobals[index] = r.unpack(1)
        allConditions[index] = r.unpack(2)
        index = index + 1
    end
    actionMergeTable = 'Matchbox/MergeTable.lua'
    nameMergeGlobals = 'parallel-group-end-merge-globals-pre-'..testName
    -- use forkRoot's globals as base globals
    local rMergedGlobals = dag.add(nameMergeGlobals, actionMergeTable, {}, forkRoot.unpack(1),
                                  table.unpack(allGlobals))
    nameMergeConditions = 'parallel-group-end-merge-conditions-pre-'..testName
    -- use forkRoot's conditions as base conditions
    local rMergedConditions = dag.add(nameMergeConditions, actionMergeTable, {},
                                     forkRoot.unpack(2), table.unpack(allConditions))

    return rMergedGlobals, rMergedConditions
end

-- add action, create and apply policy if any
local function addTestToDAG(dag, testName, action, plugins, test, ...)
    local resolvable = dag.add(testName, action, plugins, test, ...)
    if test.policy == nil then
        if test.Policy == 'R' then
            Log.LogInfo('Creating rendezvous policy for '..test.TestName)
            test.policy = Group.createPolicy(Group.syncType.rendezvous)
        elseif test.Policy == 'E' then
            Log.LogInfo('Creating exclusion policy for '..test.TestName)
            test.policy = Group.createPolicy(Group.syncType.exclusion)
        end
    end
    if test.policy ~= nil then
        dag.policy(test.policy, resolvable)
        Log.LogDebug('policy applied to '..testName)
    end
    return resolvable
end

-- schedule tests in dag.
-- This function add policy obj to the input 'mainItems' table;
-- the other DUT should also use the same test table to share the policy obj
-- created by this DUT.
-- @param dag: scheduler.
-- @param action: string for action lua file name
-- @param mainItems: tables of necessary parameter for different items
-- @param initialGlobals: global variable table before execution
-- @param initialConditions: condition table before execution
-- @param plugins: plugin table for every scheduled action.
-- e.g. seqFunc.scheduleTests(dag, "Tech.lua", mainItems, initialGlobals, initialConditions, plugins);
function SequenceControl.scheduleTests(dag, action, mainItems, initialGlobals,
                                       initialConditions, plugins)
    -- previous item's resolvable, used in sequential mode.
    local prev = nil
    -- root node of one or more parallel test flows; this node has empty Thread
    -- while the next item(s) has non-empty Thread.
    local forkRoot = nil
    -- store lastest resolvables of each parallel test group
    -- which shares the same thread id, like 1a.
    -- example: {1a = resovA2, 1b = resovB1} when A1&A2 has Thread "1a" and B1 has "1b";
    local lastNodeInThreads = {}

    local globals = initialGlobals
    local conditions = initialConditions
    -- in parallel test group, record current thread, like 1a;
    -- used to check if have illegal sequence like 1a->1b->1a
    local previousThread = nil
    -- in parallel test group, record current group number, like 1 in 1a
    -- used to check whether there are groups like
    -- 1a --> 1b --> 2a --> 2b
    -- for 2a node, we should recognize it as end of previous parallel groups
    -- and start of next parallel groups.
    local previousThreadGroupNumber = nil
    -- test: main test item
    for index, test in ipairs(mainItems) do
        local testName = test.TestName .. test.nameSuffix
        Log.LogInfo("Scheduling test: " .. testName)
        local thread = test.Thread
        if forkRoot == nil then
            if thread == nil then
                -- sequential node
                if prev ~= nil then
                    -- if nil, it is 1st item in test sequence;
                    -- use globals and conditions from args initialized above
                    globals = prev.unpack(1)
                    conditions = prev.unpack(2)
                end
                prev = addTestToDAG(dag, testName, action, plugins, test, globals, conditions)
            else
                -- thread is not nil: 1st parallel node.
                forkRoot = prev
                if forkRoot == nil then
                    -- special handling when 1st item has thread
                    forkRoot = {initialGlobals, initialConditions}
                    -- create a virtual forkRoot that can do unpack()
                    forkRoot.unpack = function(i) return forkRoot[i] end
                end
                local threadNumber = string.match(thread, "^(%d+).-$")
                previousThreadGroupNumber = threadNumber
                previousThread = thread
                Log.LogDebug('entering parallel group: '..testName)
                -- get global/conditions from root node
                -- specially if 1st node, get from virtual root created above.
                globals = forkRoot.unpack(1)
                conditions = forkRoot.unpack(2)
                lastNodeInThreads[thread] = addTestToDAG(dag, testName, action, plugins, test, globals, conditions)
                -- prev is not used in parallel groups.
                prev = nil
            end
        else
            -- inside a parallel group.
            if thread ~= nil then
                local threadNumber = string.match(thread, "^(%d+).-$")
                if threadNumber ~= previousThreadGroupNumber then
                    -- finish current parallel section
                    Log.LogDebug('2 continuous parallel groups; finishing one and starting the next.')
                    globals, conditions = finishParallelGroup(dag, testName, lastNodeInThreads, forkRoot)
                    lastNodeInThreads = {}
                    -- adding the joint node, as forkRoot of next parallel group
                    jointTestName = "parallel-group-joint-node-pre-"..testName
                    forkRoot = dag.add(jointTestName, "Matchbox/Join.lua", {}, globals, conditions)
                    -- use joint node as forkRoot
                    globals = forkRoot.unpack(1)
                    conditions = forkRoot.unpack(2)
                else
                    -- thread number stays the same, like 1a->1a or 1a->1b
                    if lastNodeInThreads[thread] ~= nil then
                        -- 1a --> 1a, or 1a --> 1b --> 1a
                        if thread ~= previousThread then
                            -- 1a --> 1b --> 1a, illegal case
                            error(testName .. ': Thread group not contineous.')
                            -- not testable because CSVSyntax check fail on this scenario
                        else
                            Log.LogDebug('In parallel group: ', thread)
                            globals = lastNodeInThreads[thread].unpack(1)
                            conditions = lastNodeInThreads[thread].unpack(2)
                        end
                    else
                        -- 1a --> 1b, starting a new thread
                        Log.LogDebug('starting new thread: ', thread)
                        globals = forkRoot.unpack(1)
                        conditions = forkRoot.unpack(2)
                    end
                end
                -- adding current node, using globals/conditions generated above

                lastNodeInThreads[thread] = addTestToDAG(dag, testName, action, plugins, test, globals, conditions)
                previousThreadGroupNumber = threadNumber
                previousThread = thread
            else
                -- thread is nil
                -- sync point: 1b --> empty Thread
                -- schedule additional node to merge globals and conditions tables.
                Log.LogDebug('Out of parallel group', testName)
                globals, conditions = finishParallelGroup(dag, testName, lastNodeInThreads, forkRoot)
                forkRoot = nil
                -- adding the joint node.
                lastNodeInThreads = {}
                previousThreadGroupNumber = nil
                previousThread = nil
                prev = addTestToDAG(dag, testName, action, plugins, test, globals, conditions)
            end
        end
    end

    -- handle situation when there is no joint node in the end
    -- for example last 3 items' Thread are 1a, 1a and 1b
    -- When scheduler can quit only when they both finish, we need a join point to generate the update global and conditions for the next section, like Teardown.
    -- Currently this should only appear once in the whole sequence, at end of test sequence;
    -- Assumes
    -- 1) Init does not use parallel group, and
    -- 2) Teardown doesn't need to generate globals/conditions
    --    for next section because there is no section after Teardown.
    if forkRoot ~= nil then
        -- hardcoded name based on assumption below
        testName = "Parallel-ending-joint-node"
        Log.LogDebug('Out of parallel group at end of sequence.')
        globals, conditions = finishParallelGroup(dag, testName, lastNodeInThreads, forkRoot)
        forkRoot = nil
        lastNodeInThreads = {}
        -- adding the joint node.
        local r = dag.add(testName, "Matchbox/Join.lua", {}, globals, conditions)
        prev = r
    end

    -- return the last item's resolvable
    -- so group.lua could get updated globals and conditions table
    -- and use it in next section, for example use in Teardown.csv
    return prev
end


-- execute one step in the tech csv
-- @param stepInfo: a table constructed by the info from the row of this step in tech csv
-- @param globals: global variable table
-- @param locals: local variable table
-- @param conditions: condition table
-- @return result: execution result of the function in this step
-- e.g. stepInfo = {TestName="some-test", TestActions="Lua:some-func", ...}; result = seqFunc.executeTechStep(stepInfo, globals, locals, CondVals);
function SequenceControl.executeTechStep(stepInfo, techFunctionTable, globals, locals, conditions, allowEditingStaticConditions)
    return SequenceControl._executeTechStep(stepInfo, techFunctionTable, globals, locals, conditions, allowEditingStaticConditions)
end


-- variable name is limited to alphanumeric and - _
-- Period could be useful for hierarchical dereferencing
-- so we don't want it in normal var name.
-- TODO: check varname in pre-flight CSV syntax check.
local pVarName = '(%s*([0-9a-zA-Z-_]+)%s*)'
local pVarNameLocal = '^%('..pVarName..'%)$'
local pVarNameGlobal = '^%['..pVarName..'%]$'
local pVarNameCondition = '^%{'..pVarName..'%}$'

-- for Input and Output varname parsing.
-- get real varname using given pattern;
-- if there is spaces around varname, report error.
local function getVarName(name, pattern)
    local nameWithPossibleSpaces, realName = name:match(pattern)
    if nameWithPossibleSpaces ~= realName then
        error(name..' unexpected space around variable name')
    end
    return realName
end

-- check whether given name represents a global variable.
-- Global variable is a variable name wrapped by a []
-- Global variable name cannot include [ or ].
-- return the actual name without [] if yes.
-- return nil when it is not.
local function nameIsGlobal(name)
    return getVarName(name, pVarNameGlobal)
end

-- check whether given name represents a local variable.
-- Local variable is a variable name wrapped by a ()
-- Local variable name cannot include ( or ).
-- return the actual name without () if yes.
-- return nil when it is not.
local function nameIsLocal(name)
    return getVarName(name, pVarNameLocal)
end


-- check whether given name represents a condition.
-- Condtion is a variable name wrapped by a {}
-- Condition name cannot include { or }.
-- return the actual name without {} if yes.
-- return nil when it is not.
local function nameIsCondition(name)
    return getVarName(name, pVarNameCondition)
end

-- return variable name type and varname for Input and Output.
-- TODO: handle case for (A)-(B) which is a string, not a local.
local SCOPE_LOCAL = 'Local Variable'
local SCOPE_GLOBAL = 'Global Variable'
local SCOPE_CONDITION = 'Condition'
local function checkVariableName(name)
    local ret = nameIsGlobal(name)
    if ret then return SCOPE_GLOBAL, ret end
    ret = nameIsCondition(name)
    if ret then return SCOPE_CONDITION, ret end
    ret = nameIsLocal(name)
    if ret then return SCOPE_LOCAL, ret end
    -- not an variable.
    return 'string', name
end


function SequenceControl._executeTechStep(stepInfo, techFunctionTable, globals, locals, conditions, allowEditingStaticConditions)
    local stepInfo = comFunc.clone(stepInfo)
    local tech = stepInfo.Technology
    local testname = stepInfo.TestName
    local actionPlugin, actionFunc = string.match(stepInfo.TestActions, "^([_%a%d]*)%:([_%a%d]*)$")
    local limit = stepInfo.limit
    -- techFunction: lua function to run
    local techFunction = nil

    if not actionPlugin or not actionFunc then
        error(string.format("Action format error, please check tech csv %s for item %s", tech, testname))
    end

    -- Load parameter list.
    -- Additional Parameters should not contains information that is CSV column, like Input and Retries.
    -- TODO: parse AdditionalParameters when loading CSV, not here.
    local additionalParameters = comFunc.parseParameter(stepInfo.AdditionalParameters)
    stepInfo.AdditionalParameters = additionalParameters
    -- convert Timeout and Retries to number;
    -- TODO: do this in CSV Load
    stepInfo.Timeout = tonumber(stepInfo.Timeout)
    stepInfo.Retries = tonumber(stepInfo.Retries)
    -- if csv provide para name in additional parameter, use it as subsubtestname when checking limit
    -- if not, use testname as paraName
    -- TODO: Is this right?
    paraName = stepInfo.AdditionalParameters.paraName or testname

    local actionCondition = stepInfo.Condition

    -- by default when Condition is empty, action is enabled.
    local isActEnable = true
    -- Calculate condition value to determine whether the action should run.
    -- TODO: using nil could be better than empty string.
    if actionCondition ~= "" then
        isActEnable = comFunc.calConditionVal(actionCondition, conditions)
    end
    local isActPass, actResult = false, nil

    if not isActEnable then
        -- condition not match.
        return true
    end

-- tech step enabled and condition match, should run
    -- handle Input here.
    local inputStr = comFunc.trim(stepInfo.Input)
    Log.LogDebug('Inputs: ' .. comFunc.dump(inputs))

    -- Input doesn't support a const string including comma (,). Tech function spec states use alphanumeric string in Input only.
    -- This can be investigated in the future to evaluate performance impact about support \ as escape char for comma.
    local inputs = comFunc.splitBySeveralDelimiter(inputStr, ',')
    -- values array for input.
    local inputValues = {}
    -- k-v table for input.
    local inputKeyValues = {}

    local mapping = {
        -- chances globals/conditions could be nil;
        -- having an empty table helps to report better error msg:
        -- 'global var not defined' vs 'line 346 indexing a nil obj'
        [SCOPE_LOCAL]=locals or {},
        [SCOPE_GLOBAL]=globals or {},
        [SCOPE_CONDITION]=conditions or {},
        string=stringConst
    }
    for index, input in ipairs(inputs) do
        input = comFunc.trim(input)
        local scope, inputVarName = checkVariableName(input)
        local v = mapping[scope][inputVarName]

        if v == nil then
            -- hijack the real tech function with an error
            techFunction = function() error(scope..' '..inputVarName..' not defined.') end
        else
            -- nil is stored as comFunc.NIL; restore it to real nil.
            if v == comFunc.NIL then v = nil end
            Log.LogDebug(scope..' '..inputVarName..': '..tostring(v))
            inputValues[index] = v
            inputKeyValues[inputVarName] = v
        end
    end
    -- param.Input still get the 1st value, for backward compatibility and easy to use when there is only 1 item in Input
    stepInfo.Input = inputValues[1]
    stepInfo.InputValues = inputValues
    stepInfo.InputDict = inputKeyValues
    stepInfo.getInput = function()
        return table.unpack(inputValues)
    end

    -- Input handling done.

    -- Calculate condition value to determine whether the limit should be applied.
    -- TODO: parse condition string when loading CSV so we know which condition value to check
    -- this can avoid 1) parsing condition here 2) passing the whole condition table into calConditionVal
    if limit and limit[paraName] and limit[paraName].Condition ~= "" then
       stepInfo.isLimitApplied = comFunc.calConditionVal(limit[paraName].Condition, conditions)
    end

    local retries = stepInfo.Retries or 1

    local varSubPatterns = {{"$(varname)", locals},
                            {"$[varname]", globals},
                            {"${varname}", conditions}}

    -- generate varSubCmd() to support variable substitution
    stepInfo.varSubCmd = function()
        local s = stepInfo.Commands
        local sub = require 'VariableSubstitute'
        -- sub.sub should error out when variable value is comFunc.NIL
        return sub.sub(s, varSubPatterns, {[comFunc.NIL]=true})
    end

    -- local function, not exposed to user
    local varSubDict = function(t, f)
        local sub = require 'VariableSubstitute'
        local ret = {}
        for i, v in pairs(t) do
            if type(v) == 'string' then
                ret[i] = sub.sub(v, varSubPatterns, {[comFunc.NIL]=true})
            elseif type(v) == 'table' then
                ret[i] = f(v, f)
            else
                ret[i] = v
            end
        end
        return ret
    end

    -- generate varSubAP() to enable user to do variable substitution for AdditionalParameters
    stepInfo.varSubAP = function()
        local ap = stepInfo.AdditionalParameters
        return varSubDict(ap, varSubDict)
    end

    -- Run actions defined by lua scripts.
    local isPlugin = false

    if techFunction == nil then
        if actionPlugin == "M" or actionPlugin == "Tech" or actionPlugin == "Common" then
            techFunction = techFunctionTable[actionPlugin][actionFunc]
            if techFunction == nil then
                if actionPlugin == "M" then
                    error('Action function ' .. actionFunc .. ' is not a Matchbox provided function.')
                elseif actionPlugin == "Tech" then
                    error('Action function ' .. actionFunc .. ' not found in ' .. tech .. '.lua.')
                else
                    -- Common
                    error('Action function ' .. actionFunc .. ' not found in Common.lua.')
                end
            end
        else
            -- Run actions defined by plugins.
            isPlugin = true
        end
    end

    local ret = nil
    local retryCount = 1
    local stepIndex = stepInfo.index
    -- remove access to line number index of tech csv in user tech function
    stepInfo.index = nil
    for i = 1, retries do
        retryCount = i
        if not isPlugin then
            ret = {xpcall(techFunction, debug.traceback, stepInfo)}
        else
            -- has different #arg, not able to merge with the switch above unless update API for createPluginRecord
            -- no need to enforce read-only for plugin call.
            ret = {xpcall(techFunctionTable.M.createPluginRecord, debug.traceback, stepInfo, actionPlugin, actionFunc)}
        end
        isActPass = ret[1]
        if isActPass then
            break
        end
    end
    -- record how many retries has been done when > 1
    local recordTestName = testname .. stepInfo.testNameSuffix
    if retryCount > 1 then
        local subsubtestname = paraName
        if subsubtestname == nil then subsubtestname = 'Tech_Line_' .. stepIndex end
        -- use special name to indicate it is generated by sequencer
        subsubtestname = subsubtestname .. '_Retry_Count'
        Record.createParametricRecord(retryCount, tech, recordTestName, subsubtestname)
    end

    if not isActPass then
        -- create fail record if tech function report failure by raising error.
        local errorMsg = ret[2]
        local subsubtestname = stepInfo.AdditionalParameters.subsubtestname
        if subsubtestname == nil then subsubtestname = 'Subtest_' .. stepIndex .. ' ' .. stepInfo.TestActions end
        local recordSubsubtestname = subsubtestname .. ' ERROR_FROM_TECH_FUNCTION'
        Record.createBinaryRecord(false, tech, recordTestName, recordSubsubtestname, errorMsg)

        -- run tech level FA, if defined
        if stepInfo.FA ~= nil and stepInfo.FA ~= '' then
            Log.LogDebug('Running tech level FA')
            local faItem = {}
            faItem.Technology = stepInfo.Technology
            faItem.TestName = stepInfo.FA
            faItem.failTestName = stepInfo.TestName
            -- passing failed items's subsubtestname to FA
            -- to create records
            faItem.failSubSubTestName = subsubtestname
            faItem.FA = stepInfo.FA
            faItem.process = 'TECH_FA'
            faItem.failureMessage = errorMsg
            -- FA sequence can generate their own locals and conditions
            -- but these locals and conditions don't exist outside FA
            -- except 'Hang' which is specially allowed to propagate from FA to Main
            -- smt soc station need this to skip tech lines when dut hang.
            conditions.Hang = SequenceControl.executeTechFA(faItem, comFunc.readOnly(globals),
                                                            comFunc.clone(locals),
                                                            comFunc.clone(conditions))
            Log.LogDebug('tech level FA finished.')
        end

        -- set Poison condition if defined
        if stepInfo.SetPoison and stepInfo.SetPoison:upper() == 'Y' then
            conditions.Poison = 'TRUE'
        end
    else
        -- handle Output here, after retry is done.
        local outputs = comFunc.splitBySeveralDelimiter(stepInfo.Output, ',')
        Log.LogDebug('Outputs: ' .. comFunc.dump(outputs))

        for index, output in ipairs(outputs) do
            output = comFunc.trim(output)
            local value = ret[index + 1]        -- ret's 1st item is xpcall pass/fail
            -- store nil value as a special string
            if value == nil then value = comFunc.NIL end
            local scope, varName = checkVariableName(output)

            if scope == SCOPE_GLOBAL then globals[varName] = value
            -- condition has special control:
            -- 1. all condition's name and allowed value shall be in Condition.csv
            -- 2. static contion is not allowed to modify outside of Init.csv
            elseif scope == SCOPE_CONDITION then conditionModule.setCondition(varName, value, allowEditingStaticConditions, conditions)
            elseif scope == SCOPE_LOCAL then locals[varName] = value
            else
                error(output..' '..scope..': unable to determine variable name and scope; use (), [] or {} to specify local variable, global variable or condition and use variable name with only alphanumeric, hyphen(-) and underscore(_)')
            end
        end

        -- special handling to enable sampling:
        -- conditions.enableSampling is set to true when
        -- 1. user call M:forceEnablingSampling
        -- 2. user call M:startCB and it return true
        -- conditions.enableSampling is set to false when
        -- 1. user call M:forceDisableSampling
        -- this condition is only allowed to set from nil to true or false
        -- when it already has a non-nil value, setting it again is not allowed.
        if stepInfo.TestActions == 'M:forceEnableSampling' then
            if conditions.enableSampling ~= nil then error('Sampling can only be enabled once or disabled once.') end
            conditions.enableSampling = true
        elseif stepInfo.TestActions == 'M:startCB' then
            if conditions.enableSampling ~= nil then error('Sampling can only be enabled once or disabled once.') end
            -- enable sampling when M:startCB return true
            conditions.enableSampling = ret[2]
        elseif stepInfo.TestActions == 'M:forceDisableSampling' then
            if conditions.enableSampling ~= nil then error('Sampling can only be enabled once or disabled once.') end
            -- station cannot use M:startCB needs to call M:enableSamplingWithoutCB,
            -- then write code to check if it is retest MLB, then
            -- call M:disableSampling if yes
            conditions.enableSampling = false
        end
    end
    return isActPass
end

-- run tech level FA; do not return anything; no loop; no FA handling for FA itself.
function SequenceControl._executeTechFA(itemInfo, globals, locals, conditions)
    local CSVLoad = require("Matchbox/CSVLoad")
    local TestName = itemInfo.TestName

    local testNameSuffix = itemInfo.nameSuffix or ''
    testNameSuffix = testNameSuffix .. '_TECH_FA'
    local actionTable = CSVLoad.loadTech(Atlas.assetsPath .. '/Failure.csv')

    if not comFunc.hasKey(actionTable, TestName) then
        -- name in Tech CSV "FA" cell should always be defined.
        error('FA sequence ' .. tostring(TestName) .. ' not defined in Failure.csv.')
    end

    if techFunctionTable == nil then SequenceControl.initTechFunctionTable(itemInfo.Technology) end
    local conditionsModule = require("Matchbox/Condition")

    -- run each row in FA sequence; no FA for FA sequence itself.
    for index, stepInfo in ipairs(actionTable[TestName])
    do
        stepInfo.Technology = itemInfo.Technology
        stepInfo.failTestName = itemInfo.failTestName
        stepInfo.failSubSubTestName = itemInfo.failSubSubTestName
        -- original failed test's error message
        stepInfo.failureMessage = itemInfo.failureMessage
        stepInfo.testNameSuffix = testNameSuffix
        stepInfo.isLimitApplied = true
        stepInfo.index = index
        -- pass limit of current test to tech lua
        stepInfo.limit = itemInfo.limits and itemInfo.limits[TestName]
        stepInfo.FA = ''
        SequenceControl.executeTechStep(stepInfo, techFunctionTable, globals, locals, conditions, false)
    end
    -- Hang conditions is the only item crossing board from FA to Main
    return conditions.Hang
end

-- run actions for an item
function SequenceControl._executeTech(itemInfo, globals, conditions, allowEditingStaticConditions)
    local locals = {}
    local plist2lua = require("Matchbox/plist2lua")
    local configPath = string.gsub(Atlas.assetsPath,"Assets","Config")
    -- set log level as INFO by default
    local logLevel = LOG_LEVEL_INFO
    if comFunc.fileExists(configPath .. "/config.plist") then
        local customConfig = plist2lua.read(configPath .. "/config.plist")
        logLevel = LOGGING_LEVEL[customConfig.Log.LoggingLevel]
    end
    local actionTable = nil
    local CSVLoad = require("Matchbox/CSVLoad")
    -- Load all tech csv files
    local testname = itemInfo.testName
    local tech = itemInfo.Technology
    local testNameSuffix = itemInfo.nameSuffix or ''
    local csvToLoad = ''
    if itemInfo.process == "normal" then
        csvToLoad = '/Tech/' .. itemInfo.Technology.. '.csv'
    elseif itemInfo.process == "FA" then
        csvToLoad = '/Failure.csv'
        testNameSuffix = testNameSuffix .. '_FA'
    elseif itemInfo.process == "Init" then
        csvToLoad = '/Init.csv'
    elseif itemInfo.process == "Teardown" then
        csvToLoad = '/Teardown.csv'
    else
        error("item process should be normal/FA/Init/Teardown")
    end

    actionTable = CSVLoad.loadTech(Atlas.assetsPath .. csvToLoad)

    -- for Tech, Init or Teardown, there should be matching testname in tech csv.
    -- for FA, it is possible to have no FA sequence for certain testname.
    if itemInfo.process ~= "FA" and not comFunc.hasKey(actionTable, testname) then
        error(string.format("TestName %s not found in %s.csv", testname, tech))
    end
    if itemInfo.process == 'FA' and not comFunc.hasKey(actionTable, testname) then
        -- failed but no FA defined
        return true, globals, conditions
    end

    local isItemPass = true

    if itemInfo.loopTimes and itemInfo.loopTimes ~= 1 then
        testNameSuffix = testNameSuffix .. "_Loop" .. itemInfo.loopTurn
    end

    if techFunctionTable == nil then SequenceControl.initTechFunctionTable(itemInfo.Technology) end
    local conditionsModule = require("Matchbox/Condition")

    -- run each row in tech csv
    for index, stepInfo in ipairs(actionTable[testname])
    do
        stepInfo.Technology = tech
        stepInfo.testNameSuffix = testNameSuffix
        stepInfo.isLimitApplied = true
        stepInfo.index = index
        Log.setLogEnv(itemInfo.Technology,logLevel,itemInfo.logID,itemInfo.mainIndex,index,itemInfo.thread)
        -- pass limit of current test to tech lua
        stepInfo.limit = itemInfo.limits and itemInfo.limits[testname]
        local techStepPass = SequenceControl.executeTechStep(stepInfo, techFunctionTable, globals, locals, conditions, allowEditingStaticConditions)
        isItemPass = isItemPass and techStepPass
        if techStepPass == false then
            if stepInfo.ExitEarly and stepInfo.ExitEarly:upper() == 'Y' then
                Log.LogDebug('Exit Early.')
                break
            end
        end
    end

    return isItemPass, globals, conditions
end

-- execute one item
-- @param itemInfo: a table of necessary parameter for the item
-- @param globals: global variable table
-- @param conditions: condition table
-- @return result: execution result this item and global variable table
-- e.g. result = seqFunc.executeTech(itemInfo, globals, CondVals);
function SequenceControl.executeTech(itemInfo, globals, conditions)
    return SequenceControl._executeTechAndCatchError(SequenceControl._executeTech, itemInfo, globals, conditions, false)
end

function SequenceControl.executeInit(itemInfo, globals, conditions)
    return SequenceControl._executeTechAndCatchError(SequenceControl._executeTech, itemInfo, globals, conditions, true)
end

function SequenceControl.executeTechFA(itemInfo, globals, locals, conditions)
    return SequenceControl._executeTechAndCatchError(SequenceControl._executeTechFA, itemInfo, globals, locals, conditions)
end


-- run _executeTech and capture error(), create FAIL record then throw the error out.
-- error captured by this function should be all usage issue that block test from running.
-- This function is just to ensure a FAIL record is created.
-- for Atlas 2.31.0.0, it is strange that although error msg length here is 130 char, but if I don't capture it here and leave it to AtlasGroupProcess, the error msg length becomes 600+ and prevent a FAIL record from being created because it exceed max failureReason length 512. If Atlas fix that, we should be able to remove the pcall here and just surface the error to Tech.lua.
function SequenceControl._executeTechAndCatchError(func, itemInfo, ...)
    local ret = {xpcall(func, debug.traceback, itemInfo, ...)}
    if not ret[1] then
        -- executeTech error should be all errors that block Matchbox from running.
        local msg = ret[2]
        local testname = itemInfo.Technology
        local subtestname = itemInfo.TestName .. (itemInfo.nameSuffix or '') .. '_' .. itemInfo.process
        local subsubtestname = 'Test blocked by error; please check device.log'
        Log.LogError(msg)
        Record.createBinaryRecord(false, testname, subtestname, subsubtestname, comFunc.trimFailureMsg(msg))
        error(msg)
    else
        -- ret[2] is if action pass
        -- ret[3] is updated globals
        -- ret[4] is updated conditions
        return ret[2], ret[3], ret[4]
    end
end

-- load Tech functions that will be used in csv.
-- Table will have 3 keys:
-- {
--     "M": {functions from Matchbox Framework, Tech/Matchbox.lua},
--     "Tech": {functions from THE given $tech.lua directly under Tech folder; empty table when it does not exist}
--     "Common": {functions from Tech/Station/Common.lua; empty table when it does not exist}
-- }
-- tech: tech csv name, also "Technology" column of main csv item.
--
function SequenceControl.initTechFunctionTable(tech)
    techFunctionTable = {
        M = require "Matchbox/Matchbox", -- Modules/Matchbox/Matchbox.lua, always present
        Tech = {},
        Common = {}
    }

    -- station common tech which could be accessed in any tech csv.
    -- trying to import Tech/Station/Common.lua, if it exist.
    local modulesFolder = string.gsub(Atlas.assetsPath, "Assets", "Modules/")

    -- load Common.lua and $Tech lua
    local loadTable = {
        Common = {
            requirePath = "Tech/Common",
            file = modulesFolder .. 'Tech/Common.lua',
        },
        Tech = {
            requirePath = "Tech/" .. tech,
            file = modulesFolder .. "Tech/" .. tech .. '.lua',
        },
    }

    for key, setting in pairs(loadTable) do
        local file = setting.file
        if comFunc.fileExists(file) then
            Log.LogDebug("Loading Tech functions from " .. file)
            techFunctionTable[key] = require(setting.requirePath)
        else
            Log.LogDebug(file .. " does not exist; skip loading.")
        end
    end

end

return SequenceControl
