local common = require 'Matchbox/CommonFunc'

--  MergeTable.lua
--  Matchbox
--  Created by Shark on 2020/9/28.
--  Copyright Â© 2020 HWTE. All rights reserved.

-- used to merge multiple global var table returned from parallel threads into 1 table
-- so it can be used by join point action.
-- for example,
--
--     A1 --> A2
--   /           \
-- X               Y
--   \           /
--     B1 --> B2
--
-- A2 and B2 will both generate globals and condition table, and returned in its resolvable.
-- Stephen come with this idea, to schedule 2 more items after A2 and B2, to merge there globals and conditions, then passed to Y.
--
--     A1 --> A2  --  globals = mergeGlobal(globalsFromX, globals1, globals2, ...)
--   /           \  /                                                       \
-- X                                                                          Y
--   \           /  \                                                       /
--     B1 --> B2  --   conds = mergeCondition(conditinosFromX, conditions1, conditions2, ...)
-- This file host the action to merge 2 or more tables and return the merged table.


-- merge given tables into one; error out if key is modified in different tables.
-- to merge globals/conditions generated by multiple parallel threads.
-- @param base: base table, used to compare if any key is updated in 2 or more threads.
-- @param first: 1st table to merge
-- @param ...: other tables to merge
function main(base, first, ...)
    -- adding the rest table to first table;
    -- error if any later table coming from each parallel thread
    -- modify the same key, based on "base" table.
    local compare = common.deepCompare
    local dump = common.dump
    for i, table in ipairs{...} do
        for k, v in pairs(table) do
            local v_base = base[k]
            -- error out when multi threads update the same key, even if modifying to the same value.
            local modifyingFirst = not compare(v_base, first[k])
            local modifyingCurrent = not compare(v_base, v)
            if modifyingFirst and modifyingCurrent then
                -- failure case: x.var[1] = 1, a1.var[1] = 2, a2.var[2] = 3
                -- failure case: x.var = 1, a1.var = 2, a2.var = 3
                errorKeyModifiedInMultiThreads(k, dump(v_base), dump(first[k]), dump(v))
            end
            if modifyingCurrent then first[k] = v end
        end
    end
    return first
end

-- function to report error when given key is modified in different threads.
-- @param key: the table key to report
-- @param before: value before entering parallel threads
-- @param v1: value of the key in one threads
-- @param v2: value of the key in another threads

function errorKeyModifiedInMultiThreads(key, before, v1, v2)
    local msg = 'key '..key..' updated in different threads! '
    msg = msg..'value before parallel threads: '..tostring(before)..', values in threads: '
    msg = msg..tostring(v1)..', '..tostring(v2)
    error(msg)
end
